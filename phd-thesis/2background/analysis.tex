\section{Application Analysis}

The analysis of Android apps becomes more and more difficult currently. Both benign and malicious developers use various protection techniques, such as Java reflection, dynamic code loading and code obfuscation \cite{rastogi2013droidchameleon}, to prevent their apps from reverse-engineering. Java reflection and dynamic code loading techniques can dynamically launch specific behaviors, which can be only monitored in dynamic analysis environment instead of static analysis. Besides, in obfuscated apps, static analysis can only check the API-level behaviors of apps rather than the fine-grained behaviors, such as the URL in network connections and the phone number of sending SMS behavior.

Without above limitations of static analysis, the dynamic analysis approach is usually used for deeply analyzing apps \cite{spreitzenbarth2013mobile}. Currently, dynamic analysis uses hooking techniques for monitoring behaviors of apps. The hooking techniques can be divided into two main types: 1) hooking Android framework APIs by modifying Android system \cite{zhauniarovich2015stadyna}\cite{enck2014taintdroid}, and 2) hooking APIs used in the app process by static instrumentation \cite{backes2013appguard}\cite{davis2013retroskeleton}. Both of them have limitations to analyze trick samples. The first hooking technique has a drawback that it cannot be used on other vendors' devices except for Google Nexus devices or emulators. This gives a chance for malicious apps, which uses the device fingerprint and anti-emulator technique to evade the dynamic detection. Even though the second hooking technique does not have this drawback, but it becomes useless when apps apply anti-repacking techniques. Apps can check the integrity of themselves in runtime and enter the frozen mode to prevent dynamic analysis if the integrity is broken. Moreover, if malicious apps implement malicious behaviors in native codes, the second hooking technique still cannot detect them.

Apps are analyzed for malicious contents before being published to the app markets. Many static and dynamic analysis techniques have been proposed for Android. The ded system re-targets Dalvik bytecode into Java class files that can be analyzed by the variety of tools developed for Java. %~\cite{Enck-USENIX-2011}. In the original paper,  the FortifySCA static analysis toolset was used for detecting vulnerabilities and dangerous functionality, like leaking the device IMEI.
DroidAlarm~\cite{Zhongyang-ASIACCS-2013} performs static detection of privilege-escalation vulnerabilities in apps by constructing paths in inter-procedural call graphs from a sensitive permission to a public interface accessible to other apps. Gascon et al. employ comparsion of functional call graphs (FCG) mined using AndroGuard to detetct malicious Android apps~\cite{Gascon-AISEC-2013}

Mobile apps are analyzed for malicious contents before being published to app stores, such as Google Play Store. The analysis usually involves two categories, \textit{i.e.,} static (reasoning about an app without executing it) and dynamic (executing apps in a controlled environment and understanding their behavior). Both of these analysis techniques have their pros and cons. While the former provides an over-approximation of what a piece of code actually performs, the latter misses certain execution paths due to limited duration of the analysis and the triggering problem. Static analysis also suffers from code obfuscation problems and dynamic code updates. Dynamic analysis, on the other hand, provides a solution to these problems, but requires test cases which could execute a major/required portion of the code.
Execution of certain code paths in mobile apps depends upon a combination of various user/system events. Generally, it is hard to predict inputs which can stimulate the required behavior in these apps. This feature of mobile apps is widely used by malware developers to conceal malicious functionality. 

Code coverage is a well-known limitation of dynamic analysis approaches. However, for the purpose of security analysis rather than testing, it is required to stimulate/reach only specific points of interest (POI) in the code rather than stimulating all the code paths in an app. In literature, researchers have focused mainly on providing inputs to make an app follow a specific path. Providing the exact inputs and environment becomes very hard as different apps may require different execution environments. Moreover, not all inputs can be predicted statically, because of obfuscation or other hiding techniques.

Static analysis relies on the availability of all the information at analysis time, hence, it suffers  from dynamic features and unavailability of information that are known only at execution time, e.g., the parameters used in the dynamic code update APIs. Therefore, reflection that is a programming technique widely used by mobile app developers can be only partially investigated by current  static analysis tools. As a result, reflection is usually used by malware developers to hide malicious code. The inherent limitation of  all static analyzers  (e.g., \cite{FlowDroid_Arzt2014,Saaf_Hoffmann2013}) is the operational assumption  that the code base does not change dynamically and the targets of reflection calls can be discovered in advance. This is a clear simplification of what happens in the real world, where many apps rely on code base updates instantiated only at runtime.

Dynamic analysis techniques are especially difficult to automate due to the need of emulating a comprehensive interactions of apps with the system and a user (UI interactions). Several approaches are proposed to automate the triggering of UI events, from random event generation~\cite{Hu-AST-2011} to more advanced approaches like AppsPlayground~\cite{AppsPlayground_Rastogi2013} and SmartDroid~\cite{SmartDroid_Zheng2012}. However, all of them still have many limitations on the type of events they can handle and the coverage.



\subsection{Dynamic Code Loading}

A growing number of malware samples found in the Android ecosystem reveals that malware developers bypass such vetting processes using various evasion techniques. Previous research shows that the use of dynamic code update techniques along with various forms of obfuscation makes it extremely hard for the state-of-the-art analysis tools to understand the behavior of an app\cite{ExecuteThis_Poeplau2014, ahmad2016empirical}. Thus, the use of these evasion techniques in newly found malware is not surprising~\cite{brain-test}.

There exist approaches that enhanced static analyzers of Java code to deal with the presence of dynamic code update techniques (e.g., \cite{TamingReflection_Bodden2011}). However, they cannot be  applied directly to Android due to the differences in the Java and Android platforms. The alternative of instrumenting the app offline has the  major drawback of breaking the app signature, that some apps check  at runtime. As the app starts, it checks the integrity of the signature against  a  value hardcoded in the app and terminates if the check fails. In case of malicious apps this check may be used to conceal illicit behavior. 

