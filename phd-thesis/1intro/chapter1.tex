\chapter{Introduction}
\label{introduction}

In recent years mobile devices have become more pervasive and ubiquitous than ever before. Mobile devices are shipped with one of the available mobile operating systems (OS), depending by the vendor. In this work we would exclusively focus on the Android platform. Since its introduction in 2008, Android has emerged as the leading operating system used for handheld devices. Mobile device provides a wide range of services via installed applications (\textit{app} in short) that offer a variety of capabilities (i.e., voice/video recording, gps navigation) and functionality (i.e., contacts and sms manager, calendar) aiming to enrich users experience but also to manage and share critical and sensitive user data.
%Those variety of personal sensitive data stored on smartphone poses an appealing target for malware and spyware applications.  
Android applications are distributed via a centralized official market, the Google Play Store, applications and updates are retrieved via the official system application which comes pre-installed on all Android compatible devices. To guarantee the security of its users, Android employees an automatic hybrid analysis system, named Google Bouncer, that aims to detect potentially malicious applications before they reach the official market. Most remarkable threats addressing the Android ecosystem, both enterprise and customers, can be grouped into two sets. Those applications controlling and monitoring  the attacked device (i.e., rooting apps, intercepting apps) and those that do data ex-filtration to third-party servers of personal and sensitive data (i.e., contact list, received sms, call history). Both class of threats may employ cleaver techniques, as social engineering, in order to get installed on the user devices, there have been several evidences of apps that masquerade them-self offering an unsuspicious service (i.e., contact/sms manager, in-app game) while under the hood they do sensitive data ex-filtration to malicious third party servers.

As consequence of the constant increasing amount of mobile devices running the Android platform and its expansion over many market segments during the last years (i.e., automotive, smar tv, wearable devices), several studies have largely focused on security and privacy research fields \cite{backes2015boxify}.  A remarkable number of investigations have been focused on malware analysis mechanisms  able to operate on real-world devices or monitoring applications operating like an anti-virus countering specific well known attacks. Android privacy issues have been addressed in order to prevent sensitive data leakage which is a major threat for Android ecosystem. Despite that a running apps has its own UID, its private files space and specific set of privileges specified within its manifest file, the permission mechanism employed by Android does not allow for definition of custom fine-grained permissions. For instance, any app that has received the appropriate permission may eventually retrieve any information stored by the system contact manager, hence restricting specific contact data access to a limited set of authorized apps represents a challenging task. Also, designing a system-wise application able to monitor and prevent other application's behavior is a cumbersome task as all applications run within a sandbox enforced both at kernel-space and at user-space. Perhaps there is no concept of \textit{assigning root privilege to a certain application} in Android. As result, practical dynamic analysis on Android stock devices requires to overcome several challenges posed by the system design itself without significant system performance degradation and without altering the least-privilege model employed by Android platform which is a solid base for security abstraction build on top of it.

Perhaps, not only spyware applications pose a risk to user privacy and security but even app's security breach constitutes a sensible attack surface. In fact, user applications are tasty targets because a single bug in any of app's components eventually leads to complete leak of all app's data. Android permission are defined for application so they do not offer components granularity, a remote code execution bug in any app's component allows to execute any operations that has been granted to the attacked app. In addition, Android core components become attractive from the attacker point of view when it comes to achieve total control over the target device. In fact, Android core services are offering a wide range of critical and sensitive features to the end user, thus representing a juicy target for vulnerability hunters.

Developers usually design Android apps according to functional components offered by the Android framework as Activity, Content provider, Service, Broadcast receiver. These offer several functionalities by communicating with Android system services via the Inter-procedure communication mechanism named Binder, which constitutes another layer of abstraction. In fact, Android APIs exposed to programmers makes developing apps completely agnostic to how the underlying interaction is happening. Android applications rely on critical functionalities offered by the Android framework which is also in charge of dispatching system events and managing user interaction. Android app developers are not limited to employ only Java programming language, in fact Android offers the option to develop application functionalities entirely as native code via the Java Native Interface (JNI) mechanism. JNI offers an interface to developers for instantiating objects and invoking Java methods via native code as well as calling native functions and sharing data from Java code. The ability to employ native code within an Android app makes its analysis even more cumbersome, moreover it introduces the chance that native vulnerabilities appear as memory corruption or memory violation that otherwise would not occur thanks to the memory restrictions imposed by the JVM.


\section{Motivation and Problem Statement}

The main question we therefore want to address is: what approaches would allow to practically analyze real-world Android apps and how these would natively support analysis on stock Android devices? These approaches should not be restricted to any particular scenario nor supporting only a restricted set of Android devices. Equally important, we need a solution which offers backward compatibility and requires minimum efforts in both developing and deploying. Finally, a question of ease of development and deployment remains: can we provide these approaches without any changes to both the Android core system and the target application's code? In other words, can we offer an efficient solution that would apply on Android stock devices, hence making our approach largely system agnostic aiming to present a novel mobile application management (in short MAM) solution for Bring Your Own Device (BYOD) environments? \\
As orthogonal research topic, we want to investigate whether Android malware sandbox analysis services were designed to be resilient to evasion attacks, the main question we therefore want to address is: which artifacts and how to design them in order to prevent analysis sandbox to be detected, thus evaded by applications? 

As we started exploring the state of the art regarding Android apps  analysis we quickly realized that only a hybrid system as combination of static and dynamic analysis approaches would  offer the requested level of inspection in order to practically analyze the app behaviour.  We thus explore the Android internals, the role of security components and how different crucial components interact controlling how the user apps communicate.

The difficulty in instrumenting Android apps in order to monitor and restrict runtime behaviour is the granularity at which we can insert monitoring code and which components we require to change. A static instrumentation-based approach may offer an acceptable solution for basic and simple applications, but is definitely not suitable for enterprise scenarios where breaking the app's signature does not represent a viable solution. On the other hand, dynamic analysis often requires consistent modifications to the underlying system or application. which is also a competitive limit in different scenarios, including enterprises that might not be inclined to modify critical components as well as to enable rooting on employees devices.
%and customers that for various reasons may avoid to increase the attack surface caused by rooting their devices.

An enterprise actor might be keen to be able to easy deploy and enforce fine-grained privacy and security policy at runtime. In particular, when the BYOD approach is in place as well as according to the recently published European Regulation GDPR. To this end, enforcing customised security policies in stock Android devices, which are those devices without any root privilege guaranteed to the end user, is a quite challenging task. 

The main difficulty in analyzing Android app is its the intense events-driven behaviour and user inputs that an app relies on to change its status. How to characterize the whole behavior that an app eventually shows during its execution, how to capture its inter-procedure communications and how to monitor its dynamic behaviour via an effective and practical approach, those are the principal challenges posed by the Android system design. In fact, stock Android does not offer any runtime mechanisms for a third-party app to monitor and trace actions of other apps. Due to secure isolation offered by Android’s UID-based sandboxing mechanism, apps cannot elevate their privilege to root to monitor other apps that are running under a different UID, e.g., like AV programs are allowed to do on a desktop OS. 

As result, analyzing Android apps requires an unified approach which would take in account different layers, both Java and native, offering inter-procedure program analysis along with the capability of collecting app's concrete status at runtime. The main approaches offered by software testing research field employ two principal techniques, static and dynamic analysis. Static analysis relies on the availability of all the information at analysis time, hence, it suffers  from dynamic features and unavailability of information that are known only at execution time. Moreover, static analysis has the limitation on analyzing apps when using techniques like code obfuscation, Java reflection and dynamic code loading to cite a few. But, dynamic analysis can help in monitoring and tampering with android app's behavior more precisely during its execution. On the other hand, dynamic analysis suffers of code coverage issue that limit the amount of code that the analysis is able to cover at runtime. 

To take advantage of XXX we have been focused on employing a novel mechanism leveraging on hybrid analysis to tackle disadvantages of static analysis and take profit of YYY capabilities of dynamic analysis. Being able to design a practical and effective framework for monitoring and analyzing Android apps allows to offer a variety of services ranging from protecting user privacy as well as offering high granularity as security countermeasure to data exfiltration attacks. By static analysis of interesting hot-points in the application (i.e.,callsite to Android APIs) we are then able to guide the dynamic analysis in charge of enforcing fine-grained security and privacy policy at runtime.

In August 2015 Google has started publishing Android Security Advisories containing vulnerabilities were reported to the vendor by internal or third party researchers, few years later the Android Security Reward program were launched as a monetary (via bounty program) incentive to researcher whom reported vulnerabilities addressing the Android platform. As further step toward making a secure platform running secure application, Google more recently also launched the Google Play Security Reward Program which aims to further improve app security which will benefit developers, Android users, and the entire Google Play ecosystem. According to android security bulletins published so far, XXX CVE were assigned for a total of YYY vulnerabilities with an average risk score of ZZZ.
The process of vulnerability mining is often composed by different steps as code audit, reverse engineering and more recently fuzzing along with symbolic execution. In different stages vulnerability mining relies on different code analysis techniques that belongs to two categories: static and dynamic analysis. Each of those analysis comes with its advantages and limitations according to the context where they are being employed, the Android platform constitutes a peculiar execution environment that is highly event-based and tightly dependent on user interaction. Moreover, the core platform code is mainly written in C and C++ programming language, instead apps are primarily developed in Java but not limited to, in fact native code is employed by leveraging on the Java Native Interface (JNI). The process of mining vulnerabilities when it comes to the Android platform might easily turn into a cumbersome challenge which requires different approaches in order to be solved.

%ARTDROID
%TEICC
%APPBOX
%OCTODROID
%EVADING RUNTIME ANALYSIS


\section{Research Contributions}

This work proposes improvements to the modern analysis of Android applications, mixing a combination of static and dynamic analysis. Perhaps, mixing static and dynamic analysis produces more accurate results and allows to monitor the app being analyzed collecting concrete runtime values. Although Android applications analysis has been extensively studied in the last years, there are still several aspects that may be significantly improved. 


\subsection{ARTDroid: a virtual-method hooking framework on Android ART runtime}
%artdroid

We contribute a dynamic analysis framework for Android platform. It achieves dynamic instrumentation by altering app's virtual memory in order to insert dynamic hooks. Thanks to this technique, we begin able to monitor and control app's behaviour at runtime without any modifications to both Android framework and app's code. Dynamic instrumentation allows to divert the execution of the target method to a custom user code, both Android framework's and application's methods can be instrumented by in-memory manipulation altering the virtual-table in order to divert the intended execution flow. As introduced in Android KitKat version, the Just-in-Time (JIT) compilation of Dalvik bytecode has been replaced by the Ahead-of-Time (AOH) compilation approach as employed by the new ART runtime. This means that bytecode is compiled into native code as soon as the application is installed on the device, as consequence most of the previous dynamic techniques for the Dalvik virtual machine became ineffective.

The advantage of being able to dynamically instrument Android applications running on ART runtime become quite relevant in several scenarios: code auditing, code protection/isolation, malware analysis to name a few. In fact, being able to instrument application's behaviour at runtime permits to monitor and trace its execution observing for anomaly behaviour or malicious patterns, moreover dynamic hooks combined along with policy specification permits to achieve more fine-grained capabilities  than the ones actually offered by the platform itself.

As contribution this work propose an in-memory technique for instrumenting Android applications which could provide a benefit for different applications.

First, from the data isolation prospective, fine-grained permissions capabilities would provide a precise and effective mechanism for controlling and managing sensitive data and operations where the end user is able to define custom policy labelling a specific instance of a particular data (i.e., restrict access to private collection of pictures, business contacts/sensitive sms) without denying access to the whole set of data (i.e., camera roll, contacts list, sms list). Thus, preventing a benign applications from leaking sensitive data to third-party entities (i.e., via third-party libraries as observed in many cases).

Second, controlled execution environments (i.e., sandbox) are employed by malware analysts to confine suspicious code into an artificial environment in order to limit and contain the damage caused by the malware, eventually. Preventing the malware's execution effects (i.e., deleting/altering file, data ex-filtration, exploitation of known vulns) is a key issue concerning malware analysis, along with another remarkable that concerns its reproducibility. In the case of malware analysis is not always required to employ bare-metal environments, in fact most of the time malware code is executed within a VM or an emulator that offers more chances for kernel-level instrumentation or simply runs modified version of Android framework. Although, as has been proved by several publications XXX, it is practical to execute the code on a real-world device in order to prevent evasion by anti-emulation, artifacts detection, hardware inspection techniques able to identify an emulated or virtual executing environment, thus apps will show a benign behaviour instead of the malicious one.

%The benifit of having a secured and isolated execution environment would simply vanish if there is no chance to reproduce a particular execution (i.e., the one that effectivelly infected the device). Moreover, malware families have started to appear more frequently, thanks to repackaging and mutations, thus making characterizing app behaviour it is relevant being able to trace and monitor runtime concrete values that that would characterize the app's behaviour. For this reason, it is of remarkable help tracing code execution at runtime such that that execution would be reproducible later on. Althought, it is not always possible to reproduce the exact input that makes that particular output, dynamic analysis may offer a practical and effective approach for observing and tampering with app's behaviour at runtime.

Finally, another scenario that takes benefits from dynamic analysis  is application's code auditing. Seeking for security defeats requires a deeper knowledge about the codebase (i.e., which components implement what logic, how the relevant flow is carried in/out) and how its components interact, which can not be totally automated but static and dynamic analysis could reduce the human effort by identifying those code portion containing potential vulnerable code. To this end, our framework provides a solution to intercept particular Android APIs for security purposes,in fact observing runtime values and altering app's execution allows to collect precious information about its behaviour that are relevant to identify vulnerable patterns as well as allowing to reverse engineering that particular app's logic. 

To summarize, this work makes the following contributions.

\begin{itemize}
\item We propose ARTDroid, a framework for hooking virtual-method calls without any modifications to both the Android system and the app's code.
\item We discuss how ARTDroid is made fully compatible with any real devices running the ART runtime with root privilege.
\item We demonstrate that the hooking technique used by ARTDroid allows to intercept virtual-methods called in both Java reflection and JNI ways.
\item We discuss applications of ARTDroid on malware analysis and policy enforcement in Android apps.
\item We released ARTDroid as an open-source project \footnote{\url{https://vaioco.github.io}}. 
\end{itemize}

%As the Android platform is becoming tremendously popular, ensuring users' privacy and security poses a major concern and requires adequate measures from app developers, framework providers, and app stores. Among the massive volume of Android apps used by Android users, there exists a lot of Android malware, which become the main threat for Android users currently. A growing number of malware samples found in the Android ecosystem reveals that malware developers bypass such vetting processes using various evasion techniques. To mitigate the threat of the Android malware, static and dynamic analysis techniques are the main solutions to detect Android malware. Static analysis has the limitation on detecting the malware when using the code obfuscation, native code, Java reflection and packer. But, dynamic analysis can help detect such Android malware more precisely in its dynamic sandboxes.

\subsection{Ensuring Execution of Targeted Code Paths during Dynamic Analysis}

%teicc
One of the main challenges associated with solutions based on dynamic analysis is the triggering problem, i.e., apps require certain user/system events to follow specific paths. In this direction, the key research goal is to advance the state-of-the-art research in triggering mechanisms and design an intelligent and scalable solution for execution of targeted inter component code paths in Android apps.

To address this challenge, we apply our dynamic technique for targeting execution of interesting code portion in order to isolating some code by means of program slicing and then collect runtime values by targeted dynamic analysis, the entire process requires only the app's bytecode. The program slicing technique allows to extract a particular portion of code which is involved in creating a specific value, or participate in a specific callsite, that we are interested in analyzing. 

State-of-the-art research shows a number of triggering solutions, ranging from black- box to grey-box, for Android apps with a varied degree of code coverage \cite{mirzaei2012testing} \cite{rastogi2013appsplayground} \cite{zheng2012smartdroid} . Code coverage is a well-known limitation of dynamic analysis approaches. However, for the purpose of security analysis rather than testing, it is required to stimulate/reach only specific points of interest in the code rather than stimulating all the code paths in an app. In literature, researchers have focused mainly on providing inputs to make an app follow a specific path. Providing the exact inputs and environment becomes very hard as different apps may require different execution environments. Moreover, not all inputs can be predicted statically, because of obfuscation or other hiding techniques. In addition, existing target triggering solutions, such as \cite{rasthofer2016harvesting} and \cite{backes2016r}, are generally limited to code execution inside a signal component of the app or do not handle the dynamic code updates well.

This work contributes to achieve targeted execution of particular code in order to incremental enhance the static analysis by means of runtime concrete values. In particular, targeted execution permits to focus on analyzing only the portion code which exposes the interesting behaviour. In fact a particular portion of the code might be more relevant in terms of analysis, further reducing the amount of code to be analyzed helps also in reducing the human effort required to accomplish the entire analysis. 

Our targeted execution leverages a slicing-based analysis for the generation of data-dependent slices for arbitrary methods of interest (MOI) and on execution of the extracted slices for capturing their dynamic behavior. Motivated by the fact that malicious apps use Inter Component Communications (ICC) to exchange data, our main contribution is the automatic targeted triggering of MOI that use ICC for passing data between components. Once, we identify the interesting slices we want to execute them to capture concrete values. Thanks to our dynamic technique we do instrument the original app's entrypoint in order to load the generated slice by means of dynamic code loading capabilities and then, to jump directly to slice's entrypoint by means of reflection. By going through repetitions of this process we can harvest runtime values to improve our analysis results.

The main contributions in this regard are enlisted here.

\begin{itemize}
\item We extend the backward slicing mechanism to support ICC, \textit{i.e.,} extract slices across multiple components. Moreover, we enhance SAAF to perform data flow analysis with context-, path- and  object-sensitivity.

\item Targeted execution of the extracted inter-component slices without modification to the Android framework.

\item We design and implement a hybrid analysis system based on static data-flow analysis and dynamic execution on real-world device for improved analysis of obfuscated apps.
\end{itemize}

\subsection{AppBox: Black-Box App Sandboxing For Stock Android}
%APPBOX
%appdroid

Beside Android explosion in the consumer market, in the past decade mobile computing has also became a way for employees of organizations of all sizes to do business computing.  In many cases, expensive company-owned laptops have been replaced by cheaper phones and tablets often even owned by the employees, so called Bring Your Own Device (BYOD). Business applications are quickly being rewritten to leverage the power and the ubiquitous nature of mobile devices. Mobile computing is no longer just another way to access the corporate network: it is quickly becoming the dominant computing platform for many enterprises. In this scenario, it is important for the IT security department of the enterprise to be able to configure secure policies for its employees' devices. Mobile Device Management (MDM) and Mobile App Management (MAM) services are the $de$ $facto$ solutions for IT security administrators to enforce such enterprise policies on mobile devices.

To this end, we further investigate how to apply dynamic instrumentation for achieving fine-grained enforcing capabilities on Android stock devices. We propose AppBox, a MAM solution that would enable an enterprise to select any app from the market and to be able to perform customisation with minimum collaboration from the app developer. Particularly, the developer will not have to disclose the app source code to the enterprise nor should she be involved with code customisations for satisfying the enterprise security requirements. Being able to define fine-grained policy and enforce them at runtime permits to isolate sensitive business data when shared among different user apps and to restrict runtime behaviour according to specific constraints, which is remarkable helpful especially when the BYOD approach is in place. 

Our goal is twofold, ease to enable and maintain apps ready for enteprise-wise capabilites and to offer an easy to deploy MAM solution that allows an enterprise to enrich its apps park but still enforcing their internal policy on employees Android stock devices. We propose a novel approach enabling developers to make their apps enterprise ready by only changing one single line in the app manifest file, that in combination with our dynamic instrumentation technique allows an enterprise to easy customise that enterprise-ready application by defining fine-grained app specific policy. 

Using AppBox , an enterprise can customise any existing app, even highly-obfuscated ones, without using any SDK or modifications to the app code. AppBox allows an enterprise to define and enforce app-specific security policies to meet its business-specific needs. More importantly, AppBox works on any Android version without requiring root privileges to control the app behaviour.

As for any other MAM solution, the basic assumption in \asd is that the enterprise trusts the developer to deliver a benign app and uses \asd for customisation purposes. It is up to the enterprise to collaborate with reputable developers to deliver apps that will not include malicious logic. 

To summarise, our contributions can be listed as follows: 

\begin{enumerate}
\item We propose \asd as an MAM solution that enables an enterprise to customise any Android app without modifying the app code. Unlike traditional enterprise mobility management solutions, \asd is able to enforce dynamic policies without requiring integration with SDKs or other code modifications. Thus, it can work also on heavily obfuscated apps.

\item By using dynamic memory instrumentation, \asd monitors and enforces fine-grained security policies at both Java and native levels.

\item \asd works on stock Android devices and does not require root privileges. This is ideal especially for enterprises that support Bring Your Own Device (BYOD) policies.  

\item We have implemented \asd and performed several tests to evaluate its performance and robustness on 1000 of the most popular real-world apps using  different Android versions, including Android Oreo 8.0. 

\item We released \asd as an open source project available at the following URL\footnote{ \url{https://vaioco.github.io/projects/}}.
\end{enumerate}


\subsection{Evaluation of practical evasion of dynamic analysis systems}

%runtime sandbox 
Antivirus companies, search engines, mobile application marketplaces, and the security research community in general largely rely on dynamic code analysis systems that load potentially malicious content in a controlled environment for analysis purposes. We evaluate the state of the art of several on-line malware analysis services by collecting artifacts exposed by those sandbox. 

We implemented a probe application that collects artifacts information and transmits it to a server. The probe tool was implemented only in Java without employing reflection or other mechanism that would flag the app as suspicious by the static analyzer. The probe applications aim to collect runtime artifacts in order to give us some insights about how those sandbox artifacts were designed, whether they are randomically generated or have fixed values that does not change over different executions. 

As artifacts one would define those which are most characteristic for the particular context, we identify a remarkable number of Android artifacts that strongly characterized a real-world device allowing thus to detect those execution environment that might be artificial as malware sandbox or runtime analysis systems. Then we investigate the results discovering that most analyzed malware sandbox expose a quite predictable execution environment where artifacts have fixed values, hence app being analyzed can easily identify those artificial execution environment and evade them by exposing a benign behaviour.

To summarize, this work makes the following contributions:
\begin{itemize}
\item 1) {\bf New problem.} We propose a new Android sandbox fingerprinting technique, which is based on the careless design of usage-profiles in most current sandboxes. We observe that malware developers can collect usage-profile based fingerprints from many Android sandboxes and then leverage these fingerprints to build a generic sandbox fingerprinting scheme for the sandbox analysis evasion. 
\item 2) {\bf Implementation.} We conduct a measurement on collecting usage-profile based fingerprints on popular Android sandboxes. The results show that most Android sandboxes designers have not protected these fingerprints by generating the random fingerprints every time for running a different sample. Only few sandboxes generate the random fingerprints, but these random fingerprints are different from fingerprints in user's real phones.
\item 3) {\bf Mitigations.} We propose mitigations to further guide a proper design of these sandboxes against this hazard.
\end{itemize}

\subsection{OctoDroid: Discovering vulnerabilities in Android via Code Property Graph}
%OCTODROID

Finally, we propose a methodology aiming to enhance vulnerability mining on the Android platform by means of combining static and dynamic analysis. 
We adopt the technique proposed by Yamaguchi et at in XXX that presents a novel static analysis approach by means of Code Property Graph (CPG). This code representation enables analysts to characterize vulnerabilities as traversals in a code property graph, a joint representation of a program’s syntax, control flow, and data flow. These traversals serve as search patterns and can be expressed as queries for the graph database system. The major intuition in analyzing code via CPG is that it allows analysts building query as traversals for the underlying graph database. The graph database stores the Code Property Graph which in turn syntheses different code representations as a multigraph. This approach permits to model  potential vulnerable patterns via the query language that in turn operates on data/control flows.

%approaches like fuzzing that requires to correctly reconstruct the input as expected by the application by means of mechanism that aims to increase the code coverage. Recostructing a complex data object turns out to be a quite onerous task, especially when a Inter Process Communication mechanism is in place because it requires a detailed prior knowledge about how that object layout looks like, including object's fields which might be complex objects as well. In this scenario a query-based vulnerability patterns discoverity system would help in reducing the analyst effort for analyzing large and huge codebase. 
%The IPC communication mechanism employed by the Android platform represents exactly the perfect scenario where a fuzzer would require a detailed knowledge about the structure of the messagges being passed by the Binder, in fact the proposed approaches for discovering vulnerabilities in Android system services (XXX) applies mutations on previously recorded Binder transactions. While this approach is valueable, it is quite tied to the completeness of the preciously recorded transactions. 

In this work we employ the CPG representation to discover vulnerabilities in Android system services. Android Open Source Project (AOSP) provides the Android source code available, Android it's an open source software, thus we can easily download the Android source code of the specific release that we want to analyze.  The reasons why we focus on analyzing Android system services follow two simple but effective motivations: (I) Android system services are fundamental components of the Android framework, they are in charge of offering a varieties of core functionalities ranging from managing Activities, calls, sms and enforcing permissions at runtime. (II) system services' business logic is implemented in C++ language, which constitutes a tasty target for exploitation in comparison with the counterpart Java code.

We employ Octopus, the analysis platform proposed by Yamaguchi in XXX, that leverages on robust code parsing to construct the CPG out of the source code. Octopus robust parser offers remarkable benefits: parsing not compilable code as well as codebase even if it is not entirely available (i.e., missing includes, unavailable code portion) to cite a few, but on the other hand it does not adequately handle object oriented languages. In fact, in favor of its robustness, Octopus when parsing statements does not recognize any particular semantic related to a specific language, in other words parsing C  or C++ code is exactly the same operation for the Octopus' parser. Octopus provides both intra- and inter- procedure analysis, as long as it is able to link call-site and destination function, otherwise the data-flow algorithm would not be able to successful terminate its analysis.

To address this limitation we propose a simple but effective methodology, based on clang-tidy and clang's LibTooling library, that would require none modifications to Octopus' parser but enabling it to efficiently analyze C++ code of Android system services. The main idea is to rely on code transformation driven by the class hierarchy graph in order to produce as output a semantic-equivalent code that allows Octopus to practical enhance its parsing results. The class hierarchy graph (cite XXX) provides a complete representation of base classes and the classes which are derived from. We apply code transformations replacing ambiguous callsites, those that would make Octopus analysis ineffective, with an explicit version according to information encoded in the class hierarchy graph.

To summarize, this work makes the following contributions:

\begin{itemize}
\item To our knowledge, \asd is the first automatic tool that employs automatic modeling and discovering of vulnerability in the Android codebase via CPG representation. 
\item Unlike previous existing works, \asd 
\item An analysis plugin based on Clang/LLVM
\item We have implemented and evaluated \asd on the latest Android Orio codebase available at the time of writing. Our results show its effectiveness in discovering new vulnerabilities.
\item We release \asd as opensource to XXX
\end{itemize}

Further work on employing CPG static information for TODO

%The Binder mechanism is based on a client-server paradigm where there are two main entities: a proxy and a XXX which in turn can operate as client or server so the roles are interchangeable. The client code would call the stub component which in turn forward the data within a so-called Parcel to the Binder entrypoint which is responsible to dispatch the Parcel to the requested server counterpart. The indications of how the parcel passing through the Binder is supposed to reach its destination is stored by ZZZ and it is not explicitely stated in the Android system services source code

%There are quite a few software testing approaches that help the analyst during this process, like the symbolic/concolic execution and especially fuzzing, which in its various versions attemp to increase the code coverage while sending crafted input to the app being analyzed. In its modern form, fuzzing employes static analysis techniques to first inspect and instrument the code, then during its execution collects runtime information to increase the code coverage while observing for runtime crashes. While fuzzing shown its effectiveness in identifying vulnerabilities, even in complex codebase (i.e., chromium, XXX) and offers as one of its advantages the capability to identify a vulnerability along with providing a code triggering such vulnerable code. On the other hand, it presents a combersome triaging process requested to differentiate between exploitable and not exploitable findings and more important it needs to be driven when it comes to produce a complex input according to a particular   

%The vulnerability hunting process is  quite often high time consuming, analyzing huge codebases often require also a deep knowledge about its internal design and interactions. 

\section{Structure of the Thesis}

This thesis consists of seven chapters, six of which remain. The first two chapters provide the BLABLA